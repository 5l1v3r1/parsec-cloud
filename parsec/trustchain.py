# Parsec Cloud (https://parsec.cloud) Copyright (c) AGPLv3 2019 Scille SAS

from typing import Tuple, Optional
import pendulum
from pendulum import Pendulum

from parsec.types import DeviceID, UserID
from parsec.serde import SerdeError, Serializer, UnknownCheckedSchema, fields
from parsec.crypto import (
    CryptoError,
    VerifyKey,
    SigningKey,
    PublicKey,
    sign_and_add_meta,
    verify_signature_from,
    unsecure_extract_msg_from_signed,
    decode_signedmeta,
)


class TrustChainError(Exception):
    pass


class TrustChainInvalidDataError(TrustChainError):
    pass


class TrustChainTooOldError(TrustChainError):
    pass


class TrustChainBrokenChainError(TrustChainError):
    pass


# TODO: configurable ?
MAX_TS_BALLPARK = 30 * 60


def timestamps_in_the_ballpark(ts1: Pendulum, ts2: Pendulum) -> bool:
    """
    Useful to compare timestamp provided inside the certified payload and
    the one generated by the backend when it received the certified payload.
    """
    return abs((ts1 - ts2).total_seconds()) < MAX_TS_BALLPARK


class CertifiedDeviceSchema(UnknownCheckedSchema):
    type = fields.CheckedConstant("device", required=True)
    timestamp = fields.DateTime(required=True)
    device_id = fields.DeviceID(required=True)
    verify_key = fields.VerifyKey(required=True)


class CertifiedUserSchema(UnknownCheckedSchema):
    type = fields.CheckedConstant("user", required=True)
    timestamp = fields.DateTime(required=True)
    user_id = fields.UserID(required=True)
    public_key = fields.PublicKey(required=True)


class CertifiedDeviceRevocationSchema(UnknownCheckedSchema):
    type = fields.CheckedConstant("device_revocation", required=True)
    timestamp = fields.DateTime(required=True)
    device_id = fields.DeviceID(required=True)


certified_device_schema = Serializer(CertifiedDeviceSchema)
certified_user_schema = Serializer(CertifiedUserSchema)
certified_device_revocation_schema = Serializer(CertifiedDeviceRevocationSchema)


def _validate_certified_payload(
    schema: UnknownCheckedSchema,
    certifier_key: VerifyKey,
    payload: bytes,
    created_on: Pendulum = None,
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    try:
        raw = verify_signature_from(certifier_key, payload)
        data = schema.loads(raw)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc

    if not timestamps_in_the_ballpark(data["timestamp"], created_on):
        raise TrustChainTooOldError("Timestamp is too old.")

    return data


def certify_device(
    certifier_id: Optional[DeviceID],
    certifier_key: SigningKey,
    device_id: DeviceID,
    verify_key: VerifyKey,
    now: Pendulum = None,
) -> bytes:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        payload = certified_device_schema.dumps(
            {
                "type": "device",
                "timestamp": now or pendulum.now(),
                "device_id": device_id,
                "verify_key": verify_key,
            }
        )
        return sign_and_add_meta(certifier_id, certifier_key, payload)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def validate_payload_certified_device(
    certifier_key: VerifyKey, payload: bytes, created_on: Pendulum
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    return _validate_certified_payload(certified_device_schema, certifier_key, payload, created_on)


def unsecure_certified_device_extract_verify_key(data: bytes) -> VerifyKey:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        _, signed = decode_signedmeta(data)
        raw = unsecure_extract_msg_from_signed(signed)
        return certified_device_schema.loads(raw)["verify_key"]

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def certify_user(
    certifier_id: Optional[DeviceID],
    certifier_key: SigningKey,
    user_id: UserID,
    public_key: PublicKey,
    now: Pendulum = None,
) -> bytes:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        payload = certified_user_schema.dumps(
            {
                "type": "user",
                "timestamp": now or pendulum.now(),
                "user_id": user_id,
                "public_key": public_key,
            }
        )
        return sign_and_add_meta(certifier_id, certifier_key, payload)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def validate_payload_certified_user(
    certifier_key: VerifyKey, payload: bytes, created_on: Pendulum
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    return _validate_certified_payload(certified_user_schema, certifier_key, payload, created_on)


def unsecure_certified_user_extract_public_key(data: bytes) -> PublicKey:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        _, signed = decode_signedmeta(data)
        raw = unsecure_extract_msg_from_signed(signed)
        return certified_user_schema.loads(raw)["public_key"]

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def certify_device_revocation(
    certifier_id: DeviceID,
    certifier_key: SigningKey,
    revoked_device_id: DeviceID,
    now: Pendulum = None,
) -> bytes:
    """
    Raises:
        TrustChainInvalidDataError
    """
    try:
        payload = certified_device_revocation_schema.dumps(
            {
                "type": "device_revocation",
                "timestamp": now or pendulum.now(),
                "device_id": revoked_device_id,
            }
        )
        return sign_and_add_meta(certifier_id, certifier_key, payload)

    except (CryptoError, SerdeError) as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def validate_payload_certified_device_revocation(
    certifier_key: VerifyKey, payload: bytes, revocated_on: Pendulum
) -> dict:
    """
    Raises:
        TrustChainInvalidDataError
        TrustChainTooOldError
    """
    return _validate_certified_payload(
        certified_device_revocation_schema, certifier_key, payload, revocated_on
    )


def certified_extract_parts(certified: bytes) -> Tuple[DeviceID, bytes]:
    """
    Raises:
        TrustChainInvalidDataError
    Returns: Tuple of certifier device id and payload
    """
    try:
        return decode_signedmeta(certified)

    except CryptoError as exc:
        raise TrustChainInvalidDataError(*exc.args) from exc


def cascade_validate_devices(user, trustchain, root_device_id, root_verify_key) -> Tuple[dict]:
    """
    Raises:
        TrustChainBrokenChainError
        TrustChainInvalidDataError
        TrustChainTooOldError
    """

    def _check_current_certifier_match_previous_certifier(current_certifier, previous_certifier):
        if current_certifier != previous_certifier:
            raise TrustChainBrokenChainError(
                f"Device {current_certifier} not signed by {previous_certifier}"
            )

    user_devices = user.devices
    trustchain.update(user_devices)

    revocation_dates = {}
    for device_name, remove_device in trustchain.items():
        revocation_dates[device_name] = remove_device.revocated_on

    certifier_id, certified_payload = certified_extract_parts(user.certified_user)
    if user.user_certifier:
        previous_device = {
            "device_id": trustchain[user.user_certifier].device_id,
            "verify_key": trustchain[user.user_certifier].verify_key,
        }
        user_certifier_device = [
            {trustchain[user.user_certifier].device_name: trustchain[user.user_certifier]}
        ]
        # TODO user_devices[user.user_certifier] = RemoteDevice ?
    else:
        previous_device = {"device_id": root_device_id, "verify_key": root_verify_key}
        user_certifier_device = []
    if (
        previous_device["device_id"] != root_device_id
        and revocation_dates[previous_device["device_id"]]
        and revocation_dates[previous_device["device_id"]] < user.created_on
    ):
        raise TrustChainBrokenChainError("Revocated user")
    validated = validate_payload_certified_user(
        previous_device["verify_key"], certified_payload, user.created_on
    )
    if user.is_revocated():
        raise TrustChainBrokenChainError("Revocated user")

    certified_devices = []
    revocated_devices = []
    for mapping in [user_devices, *user_certifier_device]:
        children = []
        for device_name in mapping:
            current_device = device_name
            while current_device:
                children.append(current_device)
                certified_device = trustchain[current_device].certified_device
                device_certifier = trustchain[current_device].device_certifier
                if device_certifier:
                    previous_device = {
                        "device_id": trustchain[device_certifier].device_id,
                        "verify_key": trustchain[device_certifier].verify_key,
                    }
                else:
                    previous_device = {"device_id": root_device_id, "verify_key": root_verify_key}
                certifier_id, certified_payload = certified_extract_parts(certified_device)
                if certifier_id:
                    _check_current_certifier_match_previous_certifier(
                        certifier_id, previous_device["device_id"] or root_device_id
                    )
                device = trustchain[device_name]
                if (
                    previous_device["device_id"] != root_device_id
                    and revocation_dates[previous_device["device_id"]]
                    and revocation_dates[previous_device["device_id"]] < device.created_on
                ):
                    revocated_devices += children
                validated = validate_payload_certified_device(
                    previous_device["verify_key"], certified_payload, device.created_on
                )
                current_device = device_certifier
            certified_devices.append(device_name)

    return [trustchain[i] for i in certified_devices if i not in revocated_devices]
